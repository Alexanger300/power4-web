<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Puissance 4</title>
  <link rel="stylesheet" href="../../assets/style/style.css">
</head>
<body class="power4-body">
  <button id="Return" class="Return" onclick="window.location.href='../home_page/home_page.html'">Retour au menu</button>
  <h1>Puissance 4</h1>
  <!-- Boutons colonnes -->
  <div id="currentPlayer"></div>
  <div id="columns"></div>
  <!-- Grille -->
  <button id="restartBtn" class="restartbtn">Nouvelle partie</button>   
  <div id="board"></div>
  <div id="winnerMessage" style="font-size: 24px; color: green; margin-right: 10px;"></div>
  
<script>
const difficulty = localStorage.getItem('difficulty') || 'facile';
let rows, cols;
let antiGravity = false;
let ModeAntiGravity = false;
let turnCount = 0;
if (difficulty === 'facile') { rows = 6; cols = 7; }
else if (difficulty === 'moyen') { rows = 6; cols = 9; }
else if (difficulty === 'difficile') { rows = 7; cols = 8; }

const boardDiv = document.getElementById('board');
const columnsDiv = document.getElementById('columns');
const winnerDiv = document.getElementById('winnerMessage');
const restartBtn = document.getElementById('restartBtn');

let board = Array.from({ length: rows }, () => Array(cols).fill(''));
let currentPlayer = 'Paris';
document.getElementById('currentPlayer').textContent = `Tour actuel : ${currentPlayer}`;
// Adapter la grille CSS
boardDiv.style.gridTemplateRows = `repeat(${rows}, 55px)`;
boardDiv.style.gridTemplateColumns = `repeat(${cols}, 55px)`;

// Colonnes interactives
   function renderBoard() {
    boardDiv.innerHTML = '';
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.col = c; // nouvelle donnée : colonne
            cell.style.border = '1px solid #0c3c66';
            cell.style.borderRadius = '50%';
            cell.style.backgroundColor = 'white';
            cell.style.cursor = 'pointer';
            cell.style.overflow = 'hidden';
            cell.style.display = 'flex';
            cell.style.alignItems = 'center';
            cell.style.justifyContent = 'center';

            // Ajoute le clic direct sur la cellule
            cell.addEventListener('click', () => play(parseInt(cell.dataset.col)));

            if (board[r][c]) {
                const img = document.createElement('img');
                img.src = board[r][c] === 'Paris' ? '../../assets/pictures/PSG.png' : '../../assets/pictures/BAR.png';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.borderRadius = '50%';
                cell.appendChild(img);
            }

            boardDiv.appendChild(cell);
        }
    }
}

function checkWinner() {
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const p = board[r][c];
            if (!p) continue;

            // Horizontal
            if (c + 3 < cols &&
                board[r][c+1] === p &&
                board[r][c+2] === p &&
                board[r][c+3] === p) return p;

            // Vertical
            if (r + 3 < rows &&
                board[r+1][c] === p &&
                board[r+2][c] === p &&
                board[r+3][c] === p) return p;

            // Diagonale droite-bas
            if (r + 3 < rows && c + 3 < cols &&
                board[r+1][c+1] === p &&
                board[r+2][c+2] === p &&
                board[r+3][c+3] === p) return p;

            // Diagonale gauche-bas
            if (r + 3 < rows && c - 3 >= 0 &&
                board[r+1][c-1] === p &&
                board[r+2][c-2] === p &&
                board[r+3][c-3] === p) return p;
        }
    }
    return null;
}

function play(col) {
    disableButtons();
    toggleAIBtn.disabled = true; /*on désactive les touches durant la partie */
    gravityBtn.disabled = true; /*on désactive les touches durant la partie */
    if (antiGravity) {
        ModeAntiGravity = true;
    }

    // Jouer le coup du joueur courant
    if (!antiGravity) {
    // Gravité normale
    for (let r = rows - 1; r >= 0; r--) {
        if (board[r][col] === '') {
            board[r][col] = currentPlayer;
            break;
        }
    }
} else {
    // Mode contre gravité
    for (let r = 0; r < rows; r++) {
        if (board[r][col] === '') {
            board[r][col] = currentPlayer;
            break;
        }
    }
}
    renderBoard();
    const winner = checkWinner();

if (winner) {
    afficherImageVictoire(winner);

    //  Enregistrement victoire/défaite
    if (winner === 'Paris') {
        ajouterVictoire('Paris');   // +1 victoire joueur humain
    } else if (winner === 'Barcelone') {
        ajouterDefaite('Paris');    // +1 défaite joueur humain
    }

    disableButtons();
    toggleAIBtn.disabled = false;
    restartBtn.style.display = 'inline-block';
    return;
}



/*  Affiche l'image de victoire selon le camp gagnant */
function afficherImageVictoire(winner) {
    winnerDiv.textContent = `Le gagnant est : ${winner}`;

    // taille des images selon le gagnant
let imageSrc;
let decalage = 0; // déplacement horizontal
let vertical = 0; // déplacement vertical
let etirement = 1; // facteur d'étirement (1 = normal)

switch (winner) {
    case "Paris":
        imageSrc = "../../assets/pictures/Dembele.png";
        decalage = -110;
        vertical = -30;
        etirement = 1; // pas d'étirement
        break;
    case "Barcelone":
        imageSrc = "../../assets/pictures/yamal.png";
        decalage = -105;
        vertical = 0;
        etirement = 1.1; 
        break;
}
boardDiv.innerHTML = `
    <div class="win-inside-board">
        <img src="${imageSrc}" 
             alt="Victoire de ${winner}" 
             class="match-image"
             style="
                margin-left: ${decalage}px;
                margin-top: ${vertical}px;
                transform: scaleY(${etirement});
             ">
    </div>
`;
}

    if (board.flat().every(cell => cell !== '')) {
        boardDiv.innerHTML = `
            <img src="../css/images/Match-nul.jpg" class="match-image">
        `;
        winnerDiv.textContent = "Match nul !";
        disableButtons();
        toggleAIBtn.disabled = false;
        restartBtn.style.display = 'inline-block';
        return;
    }
    // Incrémente le nombre de tours joués
    turnCount++;

    // Tous les 3 tours, on active ou désactive automatiquement la gravité inversée
    if (turnCount % 3 === 0 && ModeAntiGravity) {
    antiGravity = !antiGravity;
    gravityBtn.textContent = antiGravity ? 'Désactiver contre gravité (auto)' : 'Activer contre gravité (auto)';
    gravityBtn.classList.toggle('active', antiGravity);
}

    // Changer de joueur
    currentPlayer = currentPlayer === 'Paris' ? 'Barcelone' : 'Paris';
    document.getElementById('currentPlayer').textContent = `Tour actuel : ${currentPlayer}`;
    

    // Si c'est le bot et qu'il est activé
    if (botEnabled && currentPlayer === 'Barcelone') {
        const chosen = botMoveMinimax(board.map(r => r.slice()));
        if (chosen !== -1) {
            setTimeout(() => play(chosen), botDelayMs);
    }
    } else {
        // Réactiver les boutons pour le joueur humain
        enableButtons();
    }
}
function enableButtons() {
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = false);
}
function disableButtons() {
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = true);
}

restartBtn.addEventListener('click', () => {
    board = Array.from({ length: rows }, () => Array(cols).fill(''));
    currentPlayer = 'Paris';
    winnerDiv.textContent = '';
    restartBtn.style.display = 'none';
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = false);
    toggleAIBtn.disabled = false;
    renderBoard();  

});

renderBoard();

</script>
<button onclick="Draw()" class="homebtn">Match Nul</button>
<script>
    function Draw(){
        const boardDiv = document.getElementById('board');
        // On vide le plateau et on met une grande image à la place
        boardDiv.innerHTML = `
        <img src="../../assets/pictures/Match-nul.jpg"
             alt="Match nul"
             class="match-image">   
    `;

    // On affiche le message et le bouton   
    winnerDiv.textContent = "Match nul !";
    disableButtons();
    restartBtn.style.display = 'inline-block';
    return;
    } 
</script>
<script>
// Configuration du bot
let botEnabled = false;           // Le bot est désactivé par défaut
const botDelayMs = 500;           // délai avant que le bot joue (500 ms)
const minimaxDepth = 2;           //L'ia va essayer de deviner 2 coups à l'avance

// Creation du bouton pour activer/désactiver le bot
const toggleAIBtn = document.createElement('button');
toggleAIBtn.id = 'toggleAIBtn';
toggleAIBtn.textContent = 'Activer IA (Barcelone)';
toggleAIBtn.style.marginLeft = '10px';
document.body.insertBefore(toggleAIBtn, document.getElementById('board').nextSibling);

toggleAIBtn.addEventListener('click', () => {
    botEnabled = !botEnabled;
    toggleAIBtn.textContent = botEnabled ? 'Désactiver IA (Barcelone)' : 'Activer IA (Barcelone)';
    toggleAIBtn.classList.toggle('active', botEnabled);
    if (botEnabled) {
        // Désactive le bouton du mode anti gravité
        gravityBtn.disabled = true;
        gravityBtn.textContent = "Le mode anti gravité  est désactive l'IA";
    } else {
        // Si l’anti-gravité est désactivée, réactive le bouton  mode anti gravité
        gravityBtn.disabled = false;
        gravityBtn.textContent = antiGravity ? 'Désactiver IA (Barcelone)' : 'Activer IA (Barcelone)';
    }
});

// Les fonctions pour l'IA

// Retourne  des colonnes valides
function getValidMoves(bd) {
    const cols = bd[0].length;
    const moves = [];
    for (let c = 0; c < cols; c++) {
        if (bd[0][c] === '') moves.push(c);
    }
    return moves;
}

// Clone et applique un coup (ne modifie pas le board original)
function applyMoveClone(bd, col, player) {
    const newB = bd.map(row => row.slice());
    for (let r = newB.length - 1; r >= 0; r--) {
        if (newB[r][col] === '') {
            newB[r][col] = player;
            break;
        }
    }
    return newB;
}

// Vérifie le gagnant pour un board donné (similaire à checkWinner mais sur un board passé en param)
function checkWinnerSim(bd) {
    const rows = bd.length;
    const cols = bd[0].length;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const p = bd[r][c];
            if (!p) continue;
            // Horizontal
            if (c + 3 < cols &&
                bd[r][c+1] === p &&
                bd[r][c+2] === p &&
                bd[r][c+3] === p) return p;
            // Vertical
            if (r + 3 < rows &&
                bd[r+1][c] === p &&
                bd[r+2][c] === p &&
                bd[r+3][c] === p) return p;
            // Diag droite-bas
            if (r + 3 < rows && c + 3 < cols &&
                bd[r+1][c+1] === p &&
                bd[r+2][c+2] === p &&
                bd[r+3][c+3] === p) return p;
            // Diag gauche-bas
            if (r + 3 < rows && c - 3 >= 0 &&
                bd[r+1][c-1] === p &&
                bd[r+2][c-2] === p &&
                bd[r+3][c-3] === p) return p;
        }
    }
    return null;
}

// Le bot réfléchit et évalue le board
function evaluateBoard(bd, botPlayer) {
    const opp = botPlayer === 'Barcelone' ? 'Paris' : 'Barcelone';
    if (checkWinnerSim(bd) === botPlayer) return 100000;
    if (checkWinnerSim(bd) === opp) return -100000;

    let score = 0;
    const rows = bd.length;
    const cols = bd[0].length;

    // Le bot réfléchit si c'est avantageux de jouer au centre
    const centerCol = Math.floor(cols / 2);
    for (let r = 0; r < rows; r++) {
        if (bd[r][centerCol] === botPlayer) score += 3;
        if (bd[r][centerCol] === opp) score -= 3;
    }

    // le bot évalue les fenêtres de 4
    function evalWindow(windowArr) {
        let botCount = 0, oppCount = 0, emptyCount = 0;
        for (const v of windowArr) {
            if (v === botPlayer) botCount++;
            else if (v === opp) oppCount++;
            else emptyCount++;
        }
        if (botCount === 4) score += 1000;
        else if (botCount === 3 && emptyCount === 1) score += 50;
        else if (botCount === 2 && emptyCount === 2) score += 10;

        if (oppCount === 4) score -= 1000;
        else if (oppCount === 3 && emptyCount === 1) score -= 80; // bloquer prioritaire
        else if (oppCount === 2 && emptyCount === 2) score -= 5;
    }

    // parcourir toutes fenêtres de 4
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols - 3; c++) {
            evalWindow([bd[r][c], bd[r][c+1], bd[r][c+2], bd[r][c+3]]);
        }
    }
    for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows - 3; r++) {
            evalWindow([bd[r][c], bd[r+1][c], bd[r+2][c], bd[r+3][c]]);
        }
    }
    for (let r = 0; r < rows - 3; r++) {
        for (let c = 0; c < cols - 3; c++) {
            evalWindow([bd[r][c], bd[r+1][c+1], bd[r+2][c+2], bd[r+3][c+3]]);
        }
    }
    for (let r = 3; r < rows; r++) {
        for (let c = 0; c < cols - 3; c++) {
            evalWindow([bd[r][c], bd[r-1][c+1], bd[r-2][c+2], bd[r-3][c+3]]);
        }
    }

    return score;
}

// Eviter que le bot prenne trop de temps pour réfléchir
function minimax(bd, depth, alpha, beta, maximizingPlayer, botPlayer) {
    const validMoves = getValidMoves(bd);
    const winner = checkWinnerSim(bd);
    const opp = botPlayer === 'Barcelone' ? 'Paris' : 'Barcelone';

    if (depth === 0 || validMoves.length === 0 || winner !== null) {
        return [evaluateBoard(bd, botPlayer), -1];
    }

    if (maximizingPlayer) {
        let value = -Infinity;
        let chosenCol = validMoves[0];
        for (const col of validMoves) {
            const child = applyMoveClone(bd, col, botPlayer);
            const [childVal] = minimax(child, depth - 1, alpha, beta, false, botPlayer);
            if (childVal > value) {
                value = childVal;
                chosenCol = col;
            }
            alpha = Math.max(alpha, value);
            if (alpha >= beta) break; // coupe alpha-beta
        }
        return [value, chosenCol];
    } else {
        let value = Infinity;
        let chosenCol = validMoves[0];
        for (const col of validMoves) {
            const child = applyMoveClone(bd, col, opp);
            const [childVal] = minimax(child, depth - 1, alpha, beta, true, botPlayer);
            if (childVal < value) {
                value = childVal;
                chosenCol = col;
            }
            beta = Math.min(beta, value);
            if (alpha >= beta) break;
        }
        return [value, chosenCol];
    }
}

// trouve le meilleur coup pour le bot
function botMoveMinimax(bd, depth = minimaxDepth) {
    const [, col] = minimax(bd, depth, -Infinity, Infinity, true, 'Barcelone');
    // si col invalide (ex -1), retourne un coup aléatoire valide
    const valids = getValidMoves(bd);
    if (col === -1) {
        return valids.length ? valids[Math.floor(Math.random() * valids.length)] : -1;
    }
    return col;
}
//restart du jeu
restartBtn.addEventListener('click', () => {
    board = Array.from({ length: rows }, () => Array(cols).fill(''));
    currentPlayer = 'Paris';
    winnerDiv.textContent = '';
    restartBtn.style.display = 'none';
    gravityBtn.disabled = false;
    toggleAIBtn.disabled = false;   
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = false);
    renderBoard();
});

// Bouton pour le mode contre gravité
const gravityBtn = document.createElement('button');
gravityBtn.textContent = 'Activer contre gravité';
gravityBtn.id = 'gravityBtn';
gravityBtn.style.marginLeft = '10px';
document.body.insertBefore(gravityBtn, document.getElementById('board').nextSibling);

gravityBtn.addEventListener('click', () => {
    antiGravity = !antiGravity;
    gravityBtn.textContent = antiGravity ? 'Désactiver contre gravité' : 'Activer contre gravité';
    gravityBtn.classList.toggle('active', antiGravity);
    if (antiGravity) {
        // Désactive le bouton du mode IA
        toggleAIBtn.disabled = true;
        toggleAIBtn.textContent = "L'IA est désactivée en mode anti-gravité";
    } else {
        // Si l’anti-gravité est désactivée, réactive le bouton  mode IA
        toggleAIBtn.disabled = false;
        toggleAIBtn.textContent = botEnabled ? 'Désactiver IA (Barcelone)' : 'Activer IA (Barcelone)';
    }
});


// === Enregistrement des victoires / défaites ===

function ajouterVictoire(joueur) {
    const pseudo = localStorage.getItem('pseudo'); // pseudo du joueur connecté
    if (!pseudo) return; // pas de joueur connecté
    if (joueur !== 'Paris') return; // seul Paris = joueur humain

    // chemin absolu depuis la racine du serveur vers src/victory/victory.php
    fetch('/ProjetHangMan/power4-web/src/victory/victory.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'pseudo=' + encodeURIComponent(pseudo)
    })
    .then(res => res.text().then(text => {
        if (!res.ok) {
            console.error('Erreur serveur (victoire) :', res.status, text);
        } else {
            console.log('Succès (victoire) :', text);
        }
    }))
    .catch(err => console.error("Erreur AJAX (victoire) :", err));
}

function ajouterDefaite(joueur) {
    const pseudo = localStorage.getItem('pseudo');
    if (!pseudo) return;
    if (joueur !== 'Paris') return;

    // chemin absolu depuis la racine du serveur vers src/defeat/defeat.php
    fetch('/ProjetHangMan/power4-web/src/defeat/defeat.php', {  
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'pseudo=' + encodeURIComponent(pseudo)
    })
    .then(res => res.text().then(text => {
        if (!res.ok) {
            console.error('Erreur serveur (défaite) :', res.status, text);
        } else {
            console.log('Succès (défaite) :', text);
        }
    }))
    .catch(err => console.error("Erreur AJAX (défaite) :", err));
}
</script>
</body>
</html>