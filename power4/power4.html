<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Puissance 4</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body class="power4-body">
  <button id="Return" class="Return" onclick="window.location.href='../home_page/home_page.html'">Retour au menu</button>
  <h1>Puissance 4</h1>
  <!-- Boutons colonnes -->
  <div id="currentPlayer"></div>
  <div id="columns"></div>
  <!-- Grille -->
  <button id="restartBtn" class="restartbtn">Nouvelle partie</button>   
  <div id="board"></div>
  <div id="winnerMessage" style="font-size: 24px; color: green; margin-right: 10px;"></div>
  
<script>
const difficulty = localStorage.getItem('difficulty') || 'facile';
let rows, cols;
let antiGravity = false;
let ModeAntiGravity = false;
let turnCount = 0;
if (difficulty === 'facile') { rows = 6; cols = 7; }
else if (difficulty === 'moyen') { rows = 6; cols = 9; }
else if (difficulty === 'difficile') { rows = 7; cols = 8; }

const boardDiv = document.getElementById('board');
const columnsDiv = document.getElementById('columns');
const winnerDiv = document.getElementById('winnerMessage');
const restartBtn = document.getElementById('restartBtn');

let board = Array.from({ length: rows }, () => Array(cols).fill(''));
let currentPlayer = 'Paris';
document.getElementById('currentPlayer').textContent = `Tour actuel : ${currentPlayer}`;
// Adapter la grille CSS
boardDiv.style.gridTemplateRows = `repeat(${rows}, 55px)`;
boardDiv.style.gridTemplateColumns = `repeat(${cols}, 55px)`;

// Colonnes interactives
   function renderBoard() {
    boardDiv.innerHTML = '';
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.col = c; // nouvelle donn√©e : colonne
            cell.style.border = '1px solid #0c3c66';
            cell.style.borderRadius = '50%';
            cell.style.backgroundColor = 'white';
            cell.style.cursor = 'pointer';
            cell.style.overflow = 'hidden';
            cell.style.display = 'flex';
            cell.style.alignItems = 'center';
            cell.style.justifyContent = 'center';

            // Ajoute le clic direct sur la cellule
            cell.addEventListener('click', () => play(parseInt(cell.dataset.col)));

            if (board[r][c]) {
                const img = document.createElement('img');
                img.src = board[r][c] === 'Paris' ? '../css/images/PSG.png' : '../css/images/BAR.png';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.borderRadius = '50%';
                cell.appendChild(img);
            }

            boardDiv.appendChild(cell);
        }
    }
}

function checkWinner() {
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const p = board[r][c];
            if (!p) continue;

            // Horizontal
            if (c + 3 < cols &&
                board[r][c+1] === p &&
                board[r][c+2] === p &&
                board[r][c+3] === p) return p;

            // Vertical
            if (r + 3 < rows &&
                board[r+1][c] === p &&
                board[r+2][c] === p &&
                board[r+3][c] === p) return p;

            // Diagonale droite-bas
            if (r + 3 < rows && c + 3 < cols &&
                board[r+1][c+1] === p &&
                board[r+2][c+2] === p &&
                board[r+3][c+3] === p) return p;

            // Diagonale gauche-bas
            if (r + 3 < rows && c - 3 >= 0 &&
                board[r+1][c-1] === p &&
                board[r+2][c-2] === p &&
                board[r+3][c-3] === p) return p;
        }
    }
    return null;
}

function play(col) {
    disableButtons();
    toggleAIBtn.disabled = true
    gravityBtn.disabled = true;
    if (antiGravity) {
        ModeAntiGravity = true;
    }

    // Jouer le coup du joueur courant
    if (!antiGravity) {
    // Gravit√© normale
    for (let r = rows - 1; r >= 0; r--) {
        if (board[r][col] === '') {
            board[r][col] = currentPlayer;
            break;
        }
    }
} else {
    // Mode contre gravit√©
    for (let r = 0; r < rows; r++) {
        if (board[r][col] === '') {
            board[r][col] = currentPlayer;
            break;
        }
    }
}
    renderBoard();
    const winner = checkWinner();

if (winner) {
    afficherImageVictoire(winner);

    // üî• Enregistrement du r√©sultat en base
    if (winner === 'Paris') {
        ajouterVictoire('Paris');   // +1 victoire joueur humain
    } else if (winner === 'Barcelone') {
        ajouterDefaite('Paris');    // +1 d√©faite joueur humain
    }

    disableButtons();
    toggleAIBtn.disabled = false;
    restartBtn.style.display = 'inline-block';
    return;
}


/**
 * Affiche l'image de victoire selon le camp gagnant
 */
function afficherImageVictoire(winner) {
    winnerDiv.textContent = `Le gagnant est : ${winner}`;

    // D√©finition des images selon le gagnant
let imageSrc;
let decalage = 0; // d√©placement horizontal
let vertical = 0; // d√©placement vertical
let etirement = 1; // facteur d'√©tirement (1 = normal)

switch (winner) {
    case "Paris":
        imageSrc = "../css/images/Dembele.png";
        decalage = -110;
        vertical = -30;
        etirement = 1; // pas d'√©tirement
        break;
    case "Barcelone":
        imageSrc = "../css/images/yamal.png";
        decalage = -105;
        vertical = 0;
        etirement = 1.1; 
        break;
}
boardDiv.innerHTML = `
    <div class="win-inside-board">
        <img src="${imageSrc}" 
             alt="Victoire de ${winner}" 
             class="match-image"
             style="
                margin-left: ${decalage}px;
                margin-top: ${vertical}px;
                transform: scaleY(${etirement});
             ">
    </div>
`;
}

    if (board.flat().every(cell => cell !== '')) {
        boardDiv.innerHTML = `
            <img src="../css/images/Match-nul.jpg" class="match-image">
        `;
        winnerDiv.textContent = "Match nul !";
        disableButtons();
        toggleAIBtn.disabled = false;
        restartBtn.style.display = 'inline-block';
        return;
    }
    // Incr√©mente le nombre de tours jou√©s
    turnCount++;

    // Tous les 3 tours, on active ou d√©sactive automatiquement la gravit√© invers√©e
    if (turnCount % 3 === 0 && ModeAntiGravity) {
    antiGravity = !antiGravity;
    gravityBtn.textContent = antiGravity ? 'D√©sactiver contre gravit√© (auto)' : 'Activer contre gravit√© (auto)';
    gravityBtn.classList.toggle('active', antiGravity);
}

    // Changer de joueur
    currentPlayer = currentPlayer === 'Paris' ? 'Barcelone' : 'Paris';
    document.getElementById('currentPlayer').textContent = `Tour actuel : ${currentPlayer}`;
    

    // Si c'est le bot et qu'il est activ√©
    if (botEnabled && currentPlayer === 'Barcelone') {
        const chosen = botMoveMinimax(board.map(r => r.slice()));
        if (chosen !== -1) {
            setTimeout(() => play(chosen), botDelayMs);
    }
    } else {
        // R√©activer les boutons pour le joueur humain
        enableButtons();
    }
}
function enableButtons() {
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = false);
}
function disableButtons() {
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = true);
}

restartBtn.addEventListener('click', () => {
    board = Array.from({ length: rows }, () => Array(cols).fill(''));
    currentPlayer = 'Paris';
    winnerDiv.textContent = '';
    restartBtn.style.display = 'none';
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = false);
    toggleAIBtn.disabled = false;
    renderBoard();  

});

renderBoard();

</script>
<button onclick="Draw()" class="homebtn">Match Nul</button>
<script>
    function Draw(){
        const boardDiv = document.getElementById('board');
        // On vide le plateau et on met une grande image √† la place
        boardDiv.innerHTML = `
        <img src="../css/images/Match-nul.jpg"
             alt="Match nul"
             class="match-image">
    `;

    // On affiche le message et le bouton   
    winnerDiv.textContent = "Match nul !";
    disableButtons();
    restartBtn.style.display = 'inline-block';
    return;
    } 
</script>
<script>
// Configuration du bot
let botEnabled = false;           // Le bot est d√©sactiv√© par d√©faut (B = bouton)
const botDelayMs = 500;           // d√©lai avant que le bot joue (500 ms)
const minimaxDepth = 2;           //L'ia va essayer de deviner 2 coups √† l'avance

// Creation du bouton pour activer/d√©sactiver le bot
const toggleAIBtn = document.createElement('button');
toggleAIBtn.id = 'toggleAIBtn';
toggleAIBtn.textContent = 'Activer IA (Barcelone)';
toggleAIBtn.style.marginLeft = '10px';
document.body.insertBefore(toggleAIBtn, document.getElementById('board').nextSibling);

toggleAIBtn.addEventListener('click', () => {
    botEnabled = !botEnabled;
    toggleAIBtn.textContent = botEnabled ? 'D√©sactiver IA (Barcelone)' : 'Activer IA (Barcelone)';
    toggleAIBtn.classList.toggle('active', botEnabled);
});

// Les fonctions pour l'IA

// Retourne colonnes valides
function getValidMoves(bd) {
    const cols = bd[0].length;
    const moves = [];
    for (let c = 0; c < cols; c++) {
        if (bd[0][c] === '') moves.push(c);
    }
    return moves;
}

// Clone et applique un coup (ne modifie pas le board original)
function applyMoveClone(bd, col, player) {
    const newB = bd.map(row => row.slice());
    for (let r = newB.length - 1; r >= 0; r--) {
        if (newB[r][col] === '') {
            newB[r][col] = player;
            break;
        }
    }
    return newB;
}

// V√©rifie le gagnant pour un board donn√© (similaire √† checkWinner mais sur un board pass√© en param)
function checkWinnerSim(bd) {
    const rows = bd.length;
    const cols = bd[0].length;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const p = bd[r][c];
            if (!p) continue;
            // Horizontal
            if (c + 3 < cols &&
                bd[r][c+1] === p &&
                bd[r][c+2] === p &&
                bd[r][c+3] === p) return p;
            // Vertical
            if (r + 3 < rows &&
                bd[r+1][c] === p &&
                bd[r+2][c] === p &&
                bd[r+3][c] === p) return p;
            // Diag droite-bas
            if (r + 3 < rows && c + 3 < cols &&
                bd[r+1][c+1] === p &&
                bd[r+2][c+2] === p &&
                bd[r+3][c+3] === p) return p;
            // Diag gauche-bas
            if (r + 3 < rows && c - 3 >= 0 &&
                bd[r+1][c-1] === p &&
                bd[r+2][c-2] === p &&
                bd[r+3][c-3] === p) return p;
        }
    }
    return null;
}

// Le bot r√©fl√©chit et √©value le board
function evaluateBoard(bd, botPlayer) {
    const opp = botPlayer === 'Barcelone' ? 'Paris' : 'Barcelone';
    if (checkWinnerSim(bd) === botPlayer) return 100000;
    if (checkWinnerSim(bd) === opp) return -100000;

    let score = 0;
    const rows = bd.length;
    const cols = bd[0].length;

    // Le bot r√©fl√©chit si c'est avantageux de jouer au centre
    const centerCol = Math.floor(cols / 2);
    for (let r = 0; r < rows; r++) {
        if (bd[r][centerCol] === botPlayer) score += 3;
        if (bd[r][centerCol] === opp) score -= 3;
    }

    // le bot √©value les fen√™tres de 4
    function evalWindow(windowArr) {
        let botCount = 0, oppCount = 0, emptyCount = 0;
        for (const v of windowArr) {
            if (v === botPlayer) botCount++;
            else if (v === opp) oppCount++;
            else emptyCount++;
        }
        if (botCount === 4) score += 1000;
        else if (botCount === 3 && emptyCount === 1) score += 50;
        else if (botCount === 2 && emptyCount === 2) score += 10;

        if (oppCount === 4) score -= 1000;
        else if (oppCount === 3 && emptyCount === 1) score -= 80; // bloquer prioritaire
        else if (oppCount === 2 && emptyCount === 2) score -= 5;
    }

    // parcourir toutes fen√™tres de 4
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols - 3; c++) {
            evalWindow([bd[r][c], bd[r][c+1], bd[r][c+2], bd[r][c+3]]);
        }
    }
    for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows - 3; r++) {
            evalWindow([bd[r][c], bd[r+1][c], bd[r+2][c], bd[r+3][c]]);
        }
    }
    for (let r = 0; r < rows - 3; r++) {
        for (let c = 0; c < cols - 3; c++) {
            evalWindow([bd[r][c], bd[r+1][c+1], bd[r+2][c+2], bd[r+3][c+3]]);
        }
    }
    for (let r = 3; r < rows; r++) {
        for (let c = 0; c < cols - 3; c++) {
            evalWindow([bd[r][c], bd[r-1][c+1], bd[r-2][c+2], bd[r-3][c+3]]);
        }
    }

    return score;
}

// Minimax avec √©lagage alpha-beta
function minimax(bd, depth, alpha, beta, maximizingPlayer, botPlayer) {
    const validMoves = getValidMoves(bd);
    const winner = checkWinnerSim(bd);
    const opp = botPlayer === 'Barcelone' ? 'Paris' : 'Barcelone';

    if (depth === 0 || validMoves.length === 0 || winner !== null) {
        return [evaluateBoard(bd, botPlayer), -1];
    }

    if (maximizingPlayer) {
        let value = -Infinity;
        let chosenCol = validMoves[0];
        for (const col of validMoves) {
            const child = applyMoveClone(bd, col, botPlayer);
            const [childVal] = minimax(child, depth - 1, alpha, beta, false, botPlayer);
            if (childVal > value) {
                value = childVal;
                chosenCol = col;
            }
            alpha = Math.max(alpha, value);
            if (alpha >= beta) break; // coupe alpha-beta
        }
        return [value, chosenCol];
    } else {
        let value = Infinity;
        let chosenCol = validMoves[0];
        for (const col of validMoves) {
            const child = applyMoveClone(bd, col, opp);
            const [childVal] = minimax(child, depth - 1, alpha, beta, true, botPlayer);
            if (childVal < value) {
                value = childVal;
                chosenCol = col;
            }
            beta = Math.min(beta, value);
            if (alpha >= beta) break;
        }
        return [value, chosenCol];
    }
}

// Wrapper pour obtenir la meilleure colonne
function botMoveMinimax(bd, depth = minimaxDepth) {
    const [, col] = minimax(bd, depth, -Infinity, Infinity, true, 'Barcelone');
    // si col invalide (ex -1), retourne un coup al√©atoire valide
    const valids = getValidMoves(bd);
    if (col === -1) {
        return valids.length ? valids[Math.floor(Math.random() * valids.length)] : -1;
    }
    return col;
}
//restart du jeu
restartBtn.addEventListener('click', () => {
    board = Array.from({ length: rows }, () => Array(cols).fill(''));
    currentPlayer = 'Paris';
    winnerDiv.textContent = '';
    restartBtn.style.display = 'none';
    gravityBtn.disabled = false;
    toggleAIBtn.disabled = false;   
    document.querySelectorAll('#columns button').forEach(btn => btn.disabled = false);
    renderBoard();
});

// Bouton pour le mode contre gravit√©
const gravityBtn = document.createElement('button');
gravityBtn.textContent = 'Activer contre gravit√©';
gravityBtn.id = 'gravityBtn';
gravityBtn.style.marginLeft = '10px';
document.body.insertBefore(gravityBtn, document.getElementById('board').nextSibling);

gravityBtn.addEventListener('click', () => {
    antiGravity = !antiGravity;
    gravityBtn.textContent = antiGravity ? 'D√©sactiver contre gravit√©' : 'Activer contre gravit√©';
    gravityBtn.classList.toggle('active', antiGravity);
    if (antiGravity) {
        // D√©sactive le bouton du mode IA
        toggleAIBtn.disabled = true;
        toggleAIBtn.textContent = "L'IA est d√©sactiv√©e en mode anti-gravit√©";
    } else {
        // Si l‚Äôanti-gravit√© est d√©sactiv√©e, r√©active le bouton  mode IA
        toggleAIBtn.disabled = false;
        toggleAIBtn.textContent = botEnabled ? 'D√©sactiver IA (Barcelone)' : 'Activer IA (Barcelone)';
    }
});


// === Enregistrement des victoires / d√©faites ===

function ajouterVictoire(joueur) {
    const pseudo = localStorage.getItem('pseudo'); // pseudo du joueur connect√©
    if (!pseudo) return; // pas de joueur connect√©
    if (joueur !== 'Paris') return; // seul Paris = joueur humain

    fetch('victory.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'pseudo=' + encodeURIComponent(pseudo)
    })
    .then(res => res.text())
    .then(data => console.log(data))
    .catch(err => console.error("Erreur AJAX :", err));
}

function ajouterDefaite(joueur) {
    const pseudo = localStorage.getItem('pseudo');
    if (!pseudo) return;
    if (joueur !== 'Paris') return;

    fetch('defeat.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'pseudo=' + encodeURIComponent(pseudo)
    })
    .then(res => res.text())
    .then(data => console.log(data))
    .catch(err => console.error("Erreur AJAX :", err));
}
</script>
</body>
</html>